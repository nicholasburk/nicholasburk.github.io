{
  "hash": "7eda0254d5e1301f20efec2b1acc671a",
  "result": {
    "markdown": "---\ntitle: \"Risk Parity Portfolio\"\ndescription: \"An exercise in understanding the mechanics of the risk parity portfolio by implementing the algorithm myself\"\ntitle-block-banner-color: white\nimage: \"thumbnail.jpg\"\ndraft: false\n---\n\n\n## Intro/Overview\n\nOne algorithm under the umbrella of portfolio optimization that sounded interesting to me is called the risk parity portfolio. All of the portfolio optimization methods are about picking a set of weights for the different assets in a portfolio to optimize some objective function. In the case of the risk parity portfolio, the weights are selected so that each asset in the portfolio contributes an equal amount of risk. Risk is measured in terms of standard deviation of returns. \n\n## Setting Up\n\n### Loading Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(quantmod) # to download stock data from Yahoo Finance\nlibrary(dplyr) # to transform data\nlibrary(tidyr) # to convert from wide to long data format\nlibrary(ggplot2) # to draw charts\n```\n:::\n\n\n### Loading Data\n\nFor this example I will pick a few tickers with different risk profiles to show how the algorithm works. I will just use one year of data since this is mainly an exercise in understanding the algorithm, not trying to actually build a trading strategy and backtest over long periods.\n\nThe quantmod package contains a function called getSymbols() which lets the user pick one or more stock symbols and specify a time period, and then it downloads the relevant data from Yahoo Finance.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pick a few tickers and download the data from Yahoo Finance\nsymbols_vec = c(\"SPY\",\"TLT\",\"GLD\",\"AAPL\",\"NFLX\",\"NVDA\")\ngetSymbols(symbols_vec, from = \"2023-01-01\", to = \"2023-12-31\")\n\n# combine adjusted close prices into one dataset\n# a bit weird because quantmod likes to return each ticker\n# as a new object in the environment\ndf_returns = data.frame()\nfor(i in 1:length(symbols_vec)){\n    # keep only the adjusted returns data\n    cmd = paste0(symbols_vec[i], \"=\", symbols_vec[i], \"[,grepl('Adjusted',colnames(\", symbols_vec[i], \"))]\")\n    eval(parse(text = cmd))\n    # combine into one data frame\n    if(i == 1){\n        cmd = paste0(\"df_returns = \", symbols_vec[i])\n        eval(parse(text = cmd))\n    }else{\n        cmd = paste0(\"df_returns = merge(df_returns, \", symbols_vec[i], \")\")\n        eval(parse(text = cmd))\n    }\n}\n\n# clean up column names\ncolnames(df_returns) = gsub(\".Adjusted\", \"\", colnames(df_returns))\n\n# transform adjusted close prices to daily returns\ndf_returns[-1,] = apply(df_returns, 2, function(x){x[2:length(x)] / x[1:(length(x)-1)] - 1})\ndf_returns = df_returns[-1,]\ndf_returns = data.frame(Date = index(df_returns), df_returns)\n```\n:::\n\n\n\n\nHere is how the data looks after this initial cleanup.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::kable(head(df_returns))\n```\n\n::: {.cell-output-display}\n|Date       |        SPY|        TLT|        GLD|       AAPL|       NFLX|       NVDA|\n|:----------|----------:|----------:|----------:|----------:|----------:|----------:|\n|2023-01-04 |  0.0077202|  0.0136999|  0.0094119|  0.0103143|  0.0490252|  0.0303180|\n|2023-01-05 | -0.0114134|  0.0041811| -0.0124515| -0.0106046|  0.0009373| -0.0328158|\n|2023-01-06 |  0.0229321|  0.0183964|  0.0187075|  0.0367939|  0.0188892|  0.0416404|\n|2023-01-09 | -0.0005668|  0.0053241|  0.0022451|  0.0040890| -0.0012042|  0.0517532|\n|2023-01-10 |  0.0070129| -0.0165499|  0.0036760|  0.0044563|  0.0392486|  0.0179805|\n|2023-01-11 |  0.0126477|  0.0162516| -0.0006868|  0.0211122| -0.0008549|  0.0057829|\n:::\n:::\n\n\n## Benchmarks\n\nIt may be helpful to look at a couple of other portfolio allocation methods to get a sense of how this method compares with other options. I will pick a couple of simple examples to compare with.\n\n### Equally Weighted Portfolio\n\nThis method allocates an equal amount of money to each asset in the portfolio. It is extremely simple, but that is part of what makes it a useful benchmark. The difference between this method and the risk parity portfolio is that the equal weights here mean equally balance-weighted, not equally risk-weighted. Putting an equal amount of money into treasuries vs tech stocks would likely mean that the money in tech stocks contributes much more risk to the portfolio compared with the money invested in treasuries. In other words, while the amount of money invested is diversified across assets, the risk is not necessarily as diversified since one asset class might represent the majority of the risk.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# weight vector for equal weight\nw1 = rep(1, ncol(df_returns)-1)\nw1 = w1/sum(w1)\nw1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667 0.1666667\n```\n:::\n:::\n\n\n### Minimum Risk Portfolio\n\nThis portfolio optimization problem can be defined as minimizing the total variance of the portfolio subject to the condition that the weights must add up to one.\n\n$$\n    Minimize \\hspace{2.5em} \\frac{1}{2} w^T \\Sigma w \\\\\n    \\text{subject to} \\hspace{2.5em} 1^T w = 1 \n$$\n\nThis optimization problem can be solved using lagrange multipliers. Construct the langrangian as the combination of the objective function and the constraints, then the two partial derivatives can be set equal to zero and used to solve for the unknown quantities of interest.\n\n$$\n    L(x,\\lambda) = f(x) - \\lambda g(x) \\\\\n    \\frac{dL}{dx} = 0 \\hspace{2.5em} \\frac{dL}{d \\lambda} = 0\n$$\nIn the context of this problem this becomes:\n\n$$\n\\begin{align}\n    L(w,\\lambda) &= \\frac{1}{2} w^T \\Sigma w - \\lambda (1^T w - 1) \\\\\n    \\frac{dL}{dw} &= \\Sigma w - \\lambda 1^T = 0 \\\\\n    w &= \\lambda \\Sigma^{-1} 1 \\\\\n    \\\\\n    \\frac{dL}{d \\lambda} &= 1^T w - 1 = 0 \\\\\n    1^T w &= 1\n\\end{align}\n$$\nMultiplying the first equation through by 1 on the left side lets us use the constraint from the second equation which removes $w$ and allows us to solve for $\\lambda$.\n\n$$\n\\begin{align}\n    w &= \\lambda \\Sigma^{-1} 1 \\\\\n    1^T w &= \\lambda 1^T \\Sigma^{-1} 1 \\\\\n    1 &= \\lambda 1^T \\Sigma^{-1} 1 \\\\\n    \\lambda &= \\frac{1}{1^T \\Sigma^{-1} 1}\n\\end{align}\n$$\nPlugging $\\lambda$ back into the equation for $w$ solves for $w$.\n\n$$\n\\begin{align}\n    w &= \\lambda \\Sigma^{-1} 1 \\\\\n    &= \\frac{\\Sigma^{-1} 1}{1^T \\Sigma^{-1} 1}\n\\end{align}\n$$\n\nThis is simple to implement, it just involves computing and then inverting the covariance matrix $\\Sigma$ for the daily returns data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# get inverse of covariance matrix of returns\ncov_mat = cov(df_returns[,-1])\ncov_mat_inv = solve(cov_mat)\n\n# compute weights\nvec1 = rep(1, nrow(cov_mat_inv))\nlambda = vec1 %*% cov_mat_inv %*% vec1\nlambda = as.numeric(1/lambda)\nw2 = as.vector(lambda * cov_mat_inv %*% vec1)\nw2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  0.61758079  0.07622508  0.41066270 -0.02959958 -0.03462770 -0.04024129\n```\n:::\n:::\n\n\nOne interesting thing to note here is that while the weights were constrained to sum to 1, they were not constrained to be non-negative. The negative weights here on the riskier assets mean that achieving the minimum variance portfolio requires taking short positions in those assets.\n\n## Risk Parity Portfolio\n\nThis time the problem is not to minimize risk, it is to impose a constraint that each asset in the portfolio contributes equally to the total risk.\n\n### Theory\n\nThe total variance of the portfolio was minimized in the objective function of the minimum variance portfolio. Standard deviation is just the square root of variance, so the total standard deviation of the portfolio is $\\sigma (w) = \\sqrt{w^T \\Sigma w}$. This can be decomposed by taking the partial derivative with respect to the weight of each individual asset in the portfolio. \n\n$$\n    \\sigma(w) = \\sum_{i=1}^N w_i \\frac{d \\sigma}{dw_i} = \\sum_{i=1}^N \\frac{w_i(\\Sigma w)_i}{\\sqrt{w^T \\Sigma w}}\n$$\n\nIn other words, asset $i$'s contribution to the total portfolio standard deviation, or its Risk Contribution (RC) is:\n\n$$\n    RC_i = \\frac{w_i(\\Sigma w)_i}{\\sqrt{w^T \\Sigma w}}\n$$\n\nThe constraint that needs to be imposed is to have each asset have the same risk contribution, which should be an equal amount of the total risk of the portfolio.\n\n$$\n    RC_i = \\frac{1}{N} \\sigma(w) = \\frac{1}{N} \\sqrt{w^T \\Sigma w}\n$$\nDividing both sides by $\\sigma(w)$ normalizes by total portfolio risk, giving us:\n\n$$\n\\begin{align}\n    \\frac{w_i(\\Sigma w)_i}{\\sqrt{w^T \\Sigma w}} &= \\frac{1}{N} \\sqrt{w^T \\Sigma w} \\\\\n    \\frac{w_i(\\Sigma w)_i}{w^T \\Sigma w} &= \\frac{1}{N}\n\\end{align}\n$$\n\nNext comes a change of variables in two places. One is substituting $b_i = \\frac{1}{N}$ which is a generalization and will allow us to specify something other than equal risk contributions if desired later. Another is $x_i = \\frac{w_i}{\\sqrt{w^T \\Sigma w}}$, or said another way, $x$ is just the weight vector $w$ normalized by total portfolio standard deviation. After this change of variables, the last equation now looks like this:\n\n$$\n\\begin{align}\n    \\frac{w_i(\\Sigma w)_i}{w^T \\Sigma w} &= \\frac{1}{N} \\\\\n    \\frac{w_i}{\\sqrt{w^T \\Sigma w}} \\Sigma \\frac{w_i}{\\sqrt{w^T \\Sigma w}} &= b_i \\\\\n    x_i (\\Sigma x)_i &= b_i \\\\\n    x_i (\\Sigma x)_i - b_i &= 0\n\\end{align}\n$$\n\nThis can be written out further to separate $x_i$ from other weights $x_j$ to yield a quadratic equation.\n\n$$\n\\begin{align}\n    x_i (\\Sigma x)_i - b_i &= 0 \\\\\n    \\sigma_{ii}^2 x_i^2 + x_i\\sum_{i=/=j}\\sigma_{ij}^2 x_j - b_i &= 0\n\\end{align}\n$$\n\nThen the solution $x_i^*$ comes from the quadratic formula $x^* = \\frac{-b + \\sqrt{b^2 - 4ac}}{2a}$\n\n$$\n    x_i^* = \\frac{-\\sum_{i=/=j}\\sigma_{ij}^2 x_j + \\sqrt{(\\sum_{i=/=j}\\sigma_{ij}^2 x_j)^2 + 4 \\sigma_{ii}^2 b_i}}{2\\sigma_{ii}^2}\n$$\n\nSince each weight $x_i$ is written in terms of the others $x_j$ we just iteratively update the weights until convergence is reached.\n\n### Implementation\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# write it as a function that takes a covariance matrix as input\nrpp <- function(cov_mat, b = NULL, tolerance = 0.00000001, max_iter = 100){\n    # initialize weights\n    # as equal weights normalized by total portfolio risk\n    x = rep(1, ncol(cov_mat))\n    x = x/sqrt(sum(cov_mat))\n    sigma_x = cov_mat %*% x\n    # use equal risk weights by default\n    if(is.null(b)){\n        b = rep(1, ncol(cov_mat))\n        b = b/sum(b)\n    }\n    # update weights\n    for(n in 1:max_iter){\n        for(i in 1:nrow(cov_mat)){\n            z = sigma_x[i] - cov_mat[i,i]*x[i]\n            x_star = (-z + sqrt(z^2 + 4*cov_mat[i,i]*b[i])) / (2*cov_mat[i,i])\n            x[i] = x_star\n            sigma_x = cov_mat %*% x\n        }\n        # check for convergence, stop if converged\n        if(max(abs(x * as.vector(cov_mat %*% x) - b)) < tolerance){\n            break\n        }\n    }\n    return(x/sum(x))\n}\n\n# get RPP weights\nw3 = rpp(cov_mat)\nw3\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.20723268 0.19614619 0.30177870 0.14234206 0.08513825 0.06736213\n```\n:::\n\n```{.r .cell-code}\n# check that the weights result in equal risk contributions\nw3 * as.vector(cov_mat %*% w3) / sqrt(as.numeric(w3 %*% cov_mat %*% w3))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.001235473 0.001235473 0.001235473 0.001235473 0.001235473 0.001235473\n```\n:::\n:::\n\n\n## Performance\n\nNow we can compare these three methods and see how they differ in terms of returns and how the weights change over time. For the purposes of this comparison I will assume that re-balancing happens monthly, and that at the start of each month the weights are calculated by looking backwards at the prior 3-month period.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pull out month as a feature\ndf_returns$month = as.integer(substr(df_returns$Date, 6, 7))\n\n# for each month get weights based on previous 3 months\ndf_backtest = data.frame()\ndf_w = data.frame()\nfor(i in 4:12){\n    # previous 3 months of returns\n    df = df_returns[(df_returns$month >= i-3) & (df_returns$month <= i-1),]\n    \n    # equal weights\n    w1 = rep(1, ncol(df)-2)\n    w1 = w1/sum(w1)\n    \n    # minimum variance weights\n    cov_mat = cov(df[,!(colnames(df) %in% c(\"Date\",\"month\"))])\n    cov_mat_inv = solve(cov_mat)\n    vec1 = rep(1, nrow(cov_mat_inv))\n    lambda = vec1 %*% cov_mat_inv %*% vec1\n    lambda = as.numeric(1/lambda)\n    w2 = as.vector(lambda * cov_mat_inv %*% vec1)\n    \n    # risk parity portfolio weights\n    w3 = rpp(cov_mat)\n    \n    # returns for the new month\n    df = df_returns[df_returns$month == i,]\n    dt = df$Date\n    df = df[,!(colnames(df) %in% c(\"Date\",\"month\"))]\n    r1 = rowSums(sweep(df, 2, w1, FUN=\"*\"))\n    r2 = rowSums(sweep(df, 2, w2, FUN=\"*\"))\n    r3 = rowSums(sweep(df, 2, w3, FUN=\"*\"))\n    rets = data.frame(Date = dt, w_eq = r1, w_min_var = r2, w_rpp = r3)\n    df_backtest = rbind(df_backtest, rets)\n    \n    # store weight vectors over time\n    w_month = data.frame(\n        Date = as.Date(paste0(\"2023-\",formatC(i, width=2, format=\"d\", flag=\"0\"),\"-01\")),\n        type = c(rep(\"eq\", 6), rep(\"min_var\", 6), rep(\"rpp\", 6)),\n        asset = rep(colnames(df), 3),\n        weight = c(w1, w2, w3)\n    )\n    df_w = rbind(df_w, w_month)\n}\n\n# plot of performance\ndf_backtest %>%\n    mutate(Date = as.Date(Date)) %>%\n    mutate(w_eq = cumprod(1 + w_eq) - 1) %>%\n    mutate(w_min_var = cumprod(1 + w_min_var) - 1) %>%\n    mutate(w_rpp = cumprod(1 + w_rpp) - 1) %>%\n    pivot_longer(!Date, names_to = \"portfolio\", values_to = \"cum_ret\") %>%\n    ggplot(aes(x = Date, y = cum_ret, color = portfolio)) +\n    geom_line() +\n    labs(y = \"Cumulative Returns\") +\n    theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![](risk_parity_portfolio_files/figure-html/compare-performance-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# plot of weights over time for the 3 different methods\ndf_w %>%\n    ggplot(aes(x = Date, y = weight, fill = asset)) +\n    geom_bar(position = \"stack\", stat = \"identity\") +\n    facet_grid(type ~ .)\n```\n\n::: {.cell-output-display}\n![](risk_parity_portfolio_files/figure-html/compare-performance-2.png){width=672}\n:::\n:::\n\n\n## Conclusion\n\nThe risk parity portfolio represents an interesting way to look at portfolio allocation problem, focusing on the constraints as the objective. I only scratched the surface of the implementation, as there are other conditions that could also be considered such as box constraints for the weights or adding other conditions to optimize for. The [riskParityPortfolio](https://cran.r-project.org/web/packages/riskParityPortfolio/index.html) R package has excellent vignettes to explain the material for the interested reader.\n",
    "supporting": [
      "risk_parity_portfolio_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}