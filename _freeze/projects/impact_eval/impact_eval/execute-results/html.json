{
  "hash": "ba9cdefad535d0c0f579f9b821725b6c",
  "result": {
    "markdown": "---\ntitle: \"Impact Evaluation\"\ndescription: \"A general summary of some consulting work I did for the American Red Cross about estimating the effect of interventions\"\ntitle-block-banner-color: white\nimage: \"thumbnail.jpg\"\ndraft: true\n---\n\n\n## Intro/Overview\n\nOne of the volunteer projects I worked on for the American Red Cross (ARC) was to help develop a cost benefit analysis for one of their programs. The International Federation of the Red Cross and Red Crescent Societies (IFRC) has a nice summary dashboard they maintain with high level information about some of their specific interventions: [https://go.ifrc.org/](https://go.ifrc.org/). \n\nOne of the programs that IFRC supports is early action or anticipatory action. Unlike a responsive program that would wait for a disaster to occur and then provide aid afterwards, an anticipatory action program aims to provide preventative aid before the disaster occurs. This can be effective for certain types of disasters where we can reasonably predict the event in advance. \n\nFor example, we might predict a coming flood using data about river levels, weather, upstream water flow, etc. If we wait until after the flood occurs, the flooding could spread water-borne diseases among the affected population and a relief effort might involve providing medicine or other forms of healthcare. Alternatively, an anticipatory action might be to provide chlorine tablets or other water treatment options before the flood occurs so that water-borne disease does not become prevalent after the flood. If effective, this type of preventative action can allow an organization to help more people with the available budget, since these types of preventative actions are often more cost efficient than treating problems after they become more serious.\n\n## Setting Up\n\n### Loading Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr) # for data manipulation\nlibrary(ggplot2) # to make plots\n```\n:::\n\n\n## Generating the Data\n\nI will generate my own fake data to use as an example for explaining some general ideas. Continuing with the flood example, let us say that we want to evaluate the effectiveness of an anticipatory action (intervention) that aimed to reduce healthcare expenditures by providing chlorine tablets immediately prior to a flood event to help reduce the incidence of water-borne disease. Based on the available budget, the treatment can only be provided to part of the affected population. Some time after the event, we survey the affected population to see what their actual healthcare expenditures were. This is the data that we use to evaluate the impact of our program.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# set seed for consistency\nset.seed(42)\ndf = data.frame()\n\n# assume total population of 1000 households\nn_households = 1000\n\n# each household has 1-7 individuals\nhh_size = sample.int(7, n_households, replace = TRUE)\n\n# generate data for each individual\nfor(i in 1:n_households){\n    hh = data.frame(\n        hh_id = i, # household ID\n        hh_size = hh_size[i], # household size\n        age = sample.int(65, hh_size[i], replace=TRUE), # age from 1-65\n        gender = ifelse(runif(hh_size[i]) < 0.5, \"M\", \"F\") # gender (M/F)\n    )\n    df = rbind(df, hh)\n}\n\n# only 100 households receive the treatment\n# and treatment is not purely random\n# households that are larger, have more young or elderly,\n# or are more female are given some preference\ntreatment_select = df %>% \n    group_by(hh_id, hh_size) %>%\n    summarise(pct_young_old = mean((age <= 12) | (age >= 50)),\n              pct_F = mean(gender == \"F\")) %>%\n    mutate(treatment_prob = hh_size + 2*pct_young_old + 2*pct_F)\n\nhh_id_treatment = sample(treatment_select$hh_id, 100, \n                         prob = treatment_select$treatment_prob)\n\ndf$treatment = ifelse(df$hh_id %in% hh_id_treatment, 1, 0)\n\n# simulate actual healthcare costs\n# hh_size increases costs because of increased exposure opportunity\n# age young or old increases costs due to weaker immune systems\n# treatment is effective and reduces costs\ndf$hc_cost = 50 + 5*df$hh_size + 20*((df$age <= 12) | (df$age >= 50)) - 20*df$treatment\n\n# add cluster error and individual error\ndf_cluster_error = data.frame(hh_id = 1:n_households, \n                              e_household = rnorm(n_households, sd = 5))\n\ndf = df %>%\n    inner_join(df_cluster_error, by = \"hh_id\") %>%\n    mutate(e_individual = rnorm(nrow(df), sd = 5)) %>%\n    mutate(hc_cost = hc_cost + e_household + e_individual)\n```\n:::\n\n\n## Average Treatment Effect\n\nThe metric we want to estimate is the average treatment effect (ATE). The ATE is the expected effect of the treatment on the target outcome. In our example, this would be the dollar amount by which the treatment reduces healthcare expenses for each individual, on average. Estimating this impact is important for evaluating an intervention because it tells us how effective the intervention was at achieving the desired outcome, and hopefully can be generalized to other events and inform decisions about whether to use this same intervention in future scenarios.\n\n### Basic Calculation\n\nThe definition for ATE is the average difference in outcomes for treated vs non-treated individuals. More formally:\n\n$$\n    ATE = E[y_1 - y_0]\n$$\nOr, writing this in terms of an estimate from a sample:\n\n$$\n    \\widehat{ATE} = \\frac{1}{N} \\sum_i (y_1(i) - y_0(i))\n$$\n\nThe problem in both of these definitions is that we never observe both $y_1(i)$ and $y_0(i)$, because any one individual either receives the treatment or does not, so we cannot observe what happened to that same individual under both scenarios. So instead, the practical solution is to examine the difference in means between the treated and untreated groups, which should be a good estimate of the ATE under certain assumptions.\n\n$$\n    E[Y|X = 1] - E[Y|X = 0]\n$$\n\n::: {.cell}\n\n```{.r .cell-code}\n# calculate simplest ATE by hand\nEY1 = mean(df$hc_cost[df$treatment == 1])\nEY0 = mean(df$hc_cost[df$treatment == 0])\nATE = EY1 - EY0\nATE\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] -17.22038\n```\n:::\n:::\n\n\n### Linear Regression\n\nA simple regression yields the same estimate for the ATE, since using a binary indicator for the treatment is effectively the same as just taking the mean for each group. This is a useful approach if you want to do anything beyond getting this single point estimate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# estimate via simple linear model\nfit = lm(hc_cost ~ treatment, data = df)\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = hc_cost ~ treatment, data = df)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-46.78 -10.53  -0.29  10.82  46.37 \n\nCoefficients:\n            Estimate Std. Error t value Pr(>|t|)    \n(Intercept)  82.8829     0.2564  323.23   <2e-16 ***\ntreatment   -17.2204     0.7449  -23.12   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 14.98 on 3872 degrees of freedom\nMultiple R-squared:  0.1213,\tAdjusted R-squared:  0.121 \nF-statistic: 534.4 on 1 and 3872 DF,  p-value: < 2.2e-16\n```\n:::\n\n```{.r .cell-code}\n# 95% confidence interval for ATE\nconfint(fit, \"treatment\", level = 0.95)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              2.5 %    97.5 %\ntreatment -18.68089 -15.75986\n```\n:::\n\n```{.r .cell-code}\n# same thing using the standard errors directly\ncoef(fit)[2] + qt(0.025, df=fit$df.residual) * summary(fit)$coefficients[2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntreatment \n-18.68089 \n```\n:::\n\n```{.r .cell-code}\ncoef(fit)[2] + qt(0.975, df=fit$df.residual) * summary(fit)$coefficients[2,2]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntreatment \n-15.75986 \n```\n:::\n:::\n\n\nThe estimated coefficient on the treatment variable is about -17, which matches the manual calculation from earlier. In other words, the estimated ATE is that receiving the treatment reduces healthcare expenditures by an average of $17 per person. However, both of these estimates do not quite match the true effect of -20 which is the effect I used to generate the data, and the 95% confidence interval does not include the true effect either.\n\n## Additional Considerations\n\nThe simple estimate for ATE above is useful to look at, but there are usually more factors that need to be considered in this type of analysis. These will differ substantially based on the situation. Here we will examine a few that are relevant to this example.\n\n### Confounding Factors\n\nA confounding factor is a variable that influences both the dependent variable and independent variable. To estimate the effect of X on Y, we must suppress the effects of confounding variables that influence both X and Y. We say that X and Y are confounded by some other variable Z whenever Z causally influences both X and Y.\n\n![](confounding.png)\n\nIn this example, there are variables such as household size and age (Z) which influence both the treatment effect (X) and healthcare expenditures (Y). They influence treatment because treatment was not assigned randomly; the assignment was weighted to prefer larger households and households with young and elderly members. They have a direct effect on healthcare costs based on how those costs were simulated in this example.\n\nWe can account for these factors by explicitly estimating their effects in the model. Another way to think about this is that the simple version of the model suffers from omitted variable bias and the previous estimate of the ATE was incorporating effects which were actually attributable to these confounding factors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# add indicator for young/elderly age group\ndf$age_young_old = ifelse((df$age <= 12) | (df$age >= 50), 1, 0)\n\n# estimate via simple linear model\nfit = lm(hc_cost ~ treatment + hh_size + age_young_old, data = df)\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = hc_cost ~ treatment + hh_size + age_young_old, data = df)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-23.5984  -4.6508   0.0531   4.9627  24.1286 \n\nCoefficients:\n               Estimate Std. Error t value Pr(>|t|)    \n(Intercept)    49.58583    0.35099  141.27   <2e-16 ***\ntreatment     -19.78987    0.35141  -56.32   <2e-16 ***\nhh_size         5.05850    0.06416   78.84   <2e-16 ***\nage_young_old  20.12385    0.22849   88.07   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 7.047 on 3870 degrees of freedom\nMultiple R-squared:  0.8058,\tAdjusted R-squared:  0.8056 \nF-statistic:  5352 on 3 and 3870 DF,  p-value: < 2.2e-16\n```\n:::\n\n```{.r .cell-code}\n# 95% confidence interval for ATE\nconfint(fit, \"treatment\", level = 0.95)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n              2.5 %   97.5 %\ntreatment -20.47883 -19.1009\n```\n:::\n:::\n\n\nAfter adjusting for these confounding factors, our ATE estimate is much closer to the true value and the 95% confidence interval includes the true value.\n\n### Inverse Probability Treatment Weights\n\nAnother method for addressing this concern around confounding is through the use of propensity scores, or inverse probability treatment weights. This is a popular method for observational studies. Unlike a randomized controlled trial (RCT) where an experiment is designed in advance to have treatment and control groups balanced across other covariates of interest, an observational study has no control over the treatment assignment and will often have treatment and control groups which are not balanced across other covariates. This technique is essentially re-weighting the observational data to make it look more it came from a balanced RCT design, which is important for estimating ATE since the calculation assumes we are comparing similar individuals.\n\n\n\n## Conclusion\n\nTo do\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}